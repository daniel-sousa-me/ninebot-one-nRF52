//inputs
var button;
var press=true;
var l1=-1;
var l2=-1;


function buttonHandler(s){
  if (global["\xFF"].watches[button]!="undefined") clearWatch(button);
  var p=w.pin.MOTOR;
  // button down
if (s.state==true) { 
    if ( l1 >=0) {clearTimeout(l1); l1=-1;}
    if ( l2 >=0) {clearTimeout(l2);l2=-1;}
    if ( offid >=0) {clearTimeout(offid);offid=-1;}
    press=true;
    //reset on long press
	l2=setTimeout(() => {
        if (digitalRead(BTN)==1) {
        NRF.setServices({},{uart:false});
        NRF.setServices({},{uart:true});  
		l2=setTimeout(() => {reset();}, 1000);
	    }
    }, 8000);
    l1=setTimeout(() => {
      euc.tgl();
	  offid=setTimeout(() => { faces[fcurr].off();fcurr=-1; }, 8000);
      press=false;
    }, 1000);
    button=setWatch(buttonHandler,BTN1, {repeat:false,debounce:10,edge:-1});
    return;
}else if (press==true && s.state==false)  { 
    if (l1 >=0) {clearTimeout(l1); l1=-1;}
    if ( l2 >=0) {clearTimeout(l2);l2=-1;}
	press=false;
	var fshow=1;
      if (fcurr<0){
        fprev=fcurr;
        fcurr=0;
        if (euc.val.conn!="OFF") fcurr=1;  
        if (faces[fcurr].init) faces[fcurr].init();
      } else {
        if (!faces[fcurr].clear || faces[fcurr].clear()){
          fprev=fcurr;
            fcurr++; 
 //           if (fcurr >= faces.length) fcurr=0;
            if (fcurr >= 2) fcurr=0;
            if (faces[fcurr].init) faces[fcurr].init();
        } else fshow=0;
      }
      if (offid>=0) clearTimeout(offid);
      var foffms=faces[fcurr].offms;
      offid=setTimeout((f)=>{
        if (f>=0 && faces[f].off) faces[f].off();
        offid=-1;fcurr=-1;
      },(foffms>0)?foffms:offms,fcurr);
      if (fshow) {faces[fcurr].show();}
} else {
    if ( l1 >=0) {clearTimeout(l1); l1=-1;}
    if ( l2 >=0) {clearTimeout(l2); l2=-1;}
}	
  button=setWatch(buttonHandler,BTN1, {repeat:false,debounce:10,edge:1});
}
button=setWatch(buttonHandler,BTN1, {repeat:false, debounce:10,edge:0});

//touch handler
var touchHandler = {
  foffnow:false,
  timeout: function(){
    if (this.fnow) this.foffms=1;
    else this.foffms=faces[fcurr].offms;
    if (this.fto==-1) { 
      if (offid>=0) {clearTimeout(offid); offid=-1;}
      offid=setTimeout((f)=>{
        if (f>=0 && faces[f].off) faces[f].off();
        offid=-1;fcurr=-1;
      },(this.foffms>0)?this.foffms:offms,fcurr);
    }else {
      if (offid>=0) {clearTimeout(offid); offid=-1;}
      offid=setTimeout((f)=>{
		if (f>=0 && faces[f].clear) faces[f].clear();
        fcurr=this.fto;
        if (this.farg!=-1){
          faces[fcurr].init(this.farg);	
		  faces[fcurr].show(this.farg);
        }else{
          faces[fcurr].init();	
		  faces[fcurr].show();
        }
        offid=setTimeout((f)=>{
          if (f>=0 && faces[f].off) faces[f].off();
          offid=-1;fcurr=-1;
        },faces[fcurr].offms,fcurr);
      },(this.foffms>0)?this.foffms:offms,fcurr); 	  
    }
    this.fnow=false;
  }
};
var i2c=new I2C();

//var i2c=I2C1;
i2c.setup({scl:w.pin.TP_SCL, sda:w.pin.TP_SDA, bitrate:100000});
digitalPulse(w.pin.TP_RESET,1,[5,50]);
var c;
setWatch(function(s){
  var tp=i2c.readFrom(0x15,7);
//  digitalPulse(w.pin.TP_RESET,1,[5,50]);
  if (fcurr>=0) touchHandler[fcurr](tp[1],tp[4],tp[6]);
  else if (tp[1]==5) {
    //digitalPulse(w.pin.MOTOR,1,30);
    if (s.time-c<0.25){buttonHandler({state:true}); buttonHandler({state:false});}
    c=s.time;
  }else if (tp[1]==1) {buttonHandler({state:true}); buttonHandler({state:false});}
  
},w.pin.TP_INT,{repeat:true, edge:"rising"}); 

//eval(require('Storage').read('inputs'));